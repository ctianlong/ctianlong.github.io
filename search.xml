<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Markdown转Html应用与实践]]></title>
    <url>%2Fposts%2Ff8b8215b%2F</url>
    <content type="text"><![CDATA[本文讲解了两种Markdown文档转Html文档的方式，并将其应用到工作API文档书写和发布中，以此实现更简便高效的API文档发布和使用。 问题背景工作项目中经常需要对外提供API接口，并提供对应的接口文档，供调用方阅读使用。 原先使用Word来书写API文档，线下发送文档给API使用者，这种方式较为不便，每当接口发生改动或新增接口时，都要将更新后的文档再次线下发送给使用者，每次发送都需要人工操作，一旦API接入的使用者数量变多，则通知并发送新文档给每一个使用者将会成为一项耗时且繁琐的工作，并且容易出现发送遗漏，导致调用方未能及时获取新的API信息。 同时，Word文档的保存与共享也较为不便，不同人手中的文档可能不是同一个版本，想要及时获取最新版的文档需要人工沟通。 解决方案为了更方便地共享和使用API文档，将文档获取转为线上，向API使用者提供统一的文档网址，通过浏览器访问阅读。 将API文档由原来的Word书写改为Markdown书写，再将Markdown文件转换为Html文档，最后将Html发布到线上地址供访问，同时也可以将Markdown源文件发布到线上地址，供我方技术人员下载，每当需要更新API文档时可在该文件基础上编辑，无需本地保存。 整个流程如下图所示，技术人员只需将最新的Markdown文件上传，后续流程便会自动化进行，其中最关键的一步是将Markdown文件通过程序自动转换为Html，下一小节将讲述如何将其转换为拥有合适页面样式的Html文档。 实现方式此处介绍两种Markdown转Html的实现方式。 第一种方式借助Github Markdown API实现，只需通过http接口，直接POST请求调用https://api.github.com/markdown，传入所需转换的Markdown文本，返回结果即为转换后的Html文档，示例如下，更多参数详见参考文档地址：Github Markdown API 1234567curl \ -X POST \ -H "Accept: application/vnd.github.v3+json" \ -d '&#123;"text": "# Markdown Title Example"&#125;'\ https://api.github.com/markdown &lt;h1&gt;&lt;a id="user-content-markdown-title-example" class="anchor" href="#markdown-title-example" aria-hidden="true"&gt;&lt;span aria-hidden="true" class="octicon octicon-link"&gt;&lt;/span&gt;&lt;/a&gt;Markdown Title Example&lt;/h1&gt; 优点： 第三方接口直接调用，简便快捷。 支持gfm风格（GitHub Flavored Markdown），配合gfm风格样式（如：https://github.com/sindresorhus/github-markdown-css）可实现代码高亮等特性。 缺点： 不够灵活，完全依赖github第三方实现，无法自定义更多转换设置和细节，如无法在指定标签中加入指定属性。 当前接口不支持Toc目录转换。 第二种方式使用开源Markdown转换三方库，推荐flexmark-java库，项目中也采用该库实现。 flexmark-java是 CommonMark（spec 0.28）解析器的Java实现，是一款具有源级别AST的CommonMark / Markdown Java解析器。它的优势在于解析速度快，灵活性强，而且能够支持自定义AST，允许对解析过程进行精细控制，内置大量解析器和常用扩展，为解析行为和 HTML 属性样式提供了更多转换设置和选项，如gfm扩展用于支持gfm风格样式，Toc扩展用于创建目录和自定义目录层级等，同时也可以自定义扩展来实现业务需求，例如为标签增加自定义属性等。 基本使用方法flexmark-java的使用也很方便，只需简单配置即可满足常规的转换需求，如下代码是项目中的配置。 1234567891011121314151617181920212223242526272829303132333435363738/** * 将入参Markdown文档转换为html文档 */public static String mdToHtmlForApiDoc(String md) &#123; // 按需添加扩展 MutableDataSet options = new MutableDataSet().set(Parser.EXTENSIONS, Arrays.asList( // 自定义扩展，为&lt;pre&gt;标签添加line-numbers的class，用于prism库代码左侧行号展示 CodePreLineNumbersExtension.create(), AutolinkExtension.create(), EmojiExtension.create(), StrikethroughExtension.create(), TaskListExtension.create(), TablesExtension.create(), TocExtension.create() )) // set GitHub table parsing options .set(TablesExtension.WITH_CAPTION, false) .set(TablesExtension.COLUMN_SPANS, false) .set(TablesExtension.MIN_HEADER_ROWS, 1) .set(TablesExtension.MAX_HEADER_ROWS, 1) .set(TablesExtension.APPEND_MISSING_COLUMNS, true) .set(TablesExtension.DISCARD_EXTRA_COLUMNS, true) .set(TablesExtension.HEADER_SEPARATOR_COLUMN_MATCH, true) // setup emoji shortcut options // uncomment and change to your image directory for emoji images if you have it setup// .set(EmojiExtension.ROOT_IMAGE_PATH, emojiInstallDirectory()) .set(EmojiExtension.USE_SHORTCUT_TYPE, EmojiShortcutType.GITHUB) .set(EmojiExtension.USE_IMAGE_TYPE, EmojiImageType.IMAGE_ONLY); return mdToHtml(md, options);&#125;private static String mdToHtml(String md, MutableDataSet options) &#123; // uncomment to convert soft-breaks to hard breaks// options.set(HtmlRenderer.SOFT_BREAK, "&lt;br /&gt;\n"); Parser parser = Parser.builder(options).build(); HtmlRenderer renderer = HtmlRenderer.builder(options).build(); Document document = parser.parse(md); return renderer.render(document);&#125; 可以根据自身需求配置各种预定义的扩展，控制转化过程以此得到想要的html内容与格式，例如TablesExtension用于配置表格参数，TocExtension会解析TOC标识生成目录，其它扩展用法可自行探索，上述代码中的CodePreLineNumbersExtension为自定义扩展，后续会讲到。举例说明实际效果。 输入示例Markdown文本： 转换后的html文本： 12345678910111213141516171819202122232425262728&lt;h2 id="markdown示例文本"&gt;Markdown示例文本&lt;/h2&gt;&lt;p&gt;Markdown是一种轻量级的「标记语言」。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;引用文本：Markdown is a text formatting syntax inspired&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id="普通内容"&gt;普通内容&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;读一本好书，就是在和高尚的人谈话。&lt;/strong&gt; ——歌德&lt;/li&gt;&lt;li&gt;&lt;em&gt;雇用制度对工人不利，但工人根本无力摆脱这个制度。&lt;/em&gt; ——阮一峰&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="表格"&gt;表格&lt;/h3&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align="left"&gt;姓名&lt;/th&gt;&lt;th align="center"&gt;年龄&lt;/th&gt;&lt;th align="right"&gt;工作&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align="left"&gt;小可爱&lt;/td&gt;&lt;td align="center"&gt;18&lt;/td&gt;&lt;td align="right"&gt;吃可爱多&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align="left"&gt;小小勇敢&lt;/td&gt;&lt;td align="center"&gt;20&lt;/td&gt;&lt;td align="right"&gt;爬棵勇敢树&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id="代码块"&gt;代码块&lt;/h3&gt;&lt;p&gt;语言名称支持: &lt;code&gt;java&lt;/code&gt;, &lt;code&gt;python&lt;/code&gt;, &lt;code&gt;js&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, &lt;code&gt;yml&lt;/code&gt;, &lt;code&gt;xml&lt;/code&gt; ...&lt;/p&gt;&lt;pre class="line-numbers"&gt;&lt;code class="language-java"&gt;public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&amp;quot;Hello,World!&amp;quot;); &#125;&#125;&lt;/code&gt;&lt;/pre&gt; 完善html文档注意，通过flexmark-java转换得到的html文档只包含网页的主体部分，即body标签里的内容，由于没有样式文件配合，还无法呈现美观的显示效果。因此，我们还需在此基础上添加html、head、body等标签，以及引入所需的link、style等样式和脚本文件来完善html文档，使之展示成最终想要的样式。 此处选择github风格的样式文件，直接引入网上开源的css文件（也可自己写样式）。同时引入prism.js实现代码高亮，最终html内容如下所示，其中&lt;article&gt;标签内填入上一步所得的html文档即可。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;示例标题&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css"/&gt; &lt;style type="text/css"&gt; .markdown-body &#123; box-sizing: border-box; min-width: 200px; max-width: 980px; margin: 0 auto; padding: 45px &#125; @media(max-width:767px) &#123; .markdown-body &#123; padding: 15px &#125; &#125; &lt;/style&gt; &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/themes/prism.min.css"/&gt; &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/plugins/line-numbers/prism-line-numbers.min.css"/&gt;&lt;/head&gt;&lt;body class="markdown-body"&gt; &lt;article&gt; ！此处替换为上一步转换得到的html文本！ &lt;/article&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/components/prism-core.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/plugins/autoloader/prism-autoloader.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/plugins/line-numbers/prism-line-numbers.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最终显示效果如下： 自定义解析扩展用prims.js实现代码行号显示时，要求在&lt;pre&gt;标签中包含line-numbers的class属性，即&lt;pre class=&quot;line-numbers&quot;&gt;，原始转换结果并不包含这个，我们通过自定义解析扩展来实现为标签添加自定义属性，即上文讲到的CodePreLineNumbersExtension。 首先自定义AttributeProvider的实现类CodePreLineNumbersAttributeProvider，代码如下，通过实现AttributeProvider来修改元素是flexmark-java常用的扩展方式之一，常规的为元素添加属性均可通过该方式实现。 123456789101112131415161718static class CodePreLineNumbersAttributeProvider implements AttributeProvider &#123; @Override public void setAttributes(@NotNull Node node, @NotNull AttributablePart part, @NotNull MutableAttributes attributes) &#123; // 定位到&lt;pre&gt;标签元素进行修改 if (node instanceof FencedCodeBlock &amp;&amp; part == AttributablePart.NODE) &#123; attributes.addValue("class", "line-numbers"); &#125; &#125; static AttributeProviderFactory Factory() &#123; return new IndependentAttributeProviderFactory() &#123; @NotNull @Override public AttributeProvider apply(@NotNull LinkResolverContext context) &#123; return new CodePreLineNumbersAttributeProvider(); &#125; &#125;; &#125;&#125; 然后需要将自定义的AttributeProvider通过HtmlRenderer.Builder.attributeProviderFactory的方式注册到CodePreLineNumbersExtension中即可使用，代码如下。 12345678910111213static class CodePreLineNumbersExtension implements HtmlRenderer.HtmlRendererExtension &#123; @Override public void rendererOptions(@NotNull MutableDataHolder options) &#123; // add any configuration settings to options you want to apply to everything, here &#125; @Override public void extend(@NotNull HtmlRenderer.Builder htmlRendererBuilder, @NotNull String rendererType) &#123; htmlRendererBuilder.attributeProviderFactory(CodePreLineNumbersAttributeProvider.Factory()); &#125; static CodePreLineNumbersExtension create() &#123; return new CodePreLineNumbersExtension(); &#125;&#125; 总结除了本文讲到的方式，将Markdown转换为Html的方式还有很多，众多对比之下，flexmark-java是相对不错且成熟的解决方案，灵活度高，可定制很多转换设置，同时可自定义扩展来增强功能。本文选择该方式来实现API文档Markdown转html并发布到线上，以此实现更简便高效的API文档发布和使用。]]></content>
      <categories>
        <category>markdown</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>markdown</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[延迟加载原理与实现]]></title>
    <url>%2Fposts%2Fb9b384eb%2F</url>
    <content type="text"><![CDATA[本文介绍日常开发中可能用到的一种数据求值策略，延迟加载，也即惰性求值。介绍延迟加载的定义与原理，讲解使用该方式带来的好处以及合适的应用场景，最后介绍Java中的一些具体实现方案。 一、延迟加载的定义与原理延迟加载是开发过程中灵活获取对象的一种求值策略，该策略在定义目标对象时并不会立即计算实际对象值，而是在该对象后续被实际调用时才去求值。在计算机科学中，延迟加载对应一个专门术语：惰性求值，其维基百科定义如下。 在编程语言理论中，惰性求值（Lazy Evaluation），又译为惰性计算、懒惰求值，也称为传需求调用（call-by-need），是计算机编程中的一个概念，目的是要最小化计算机要做的工作。延迟求值特别用于匿名式函数编程，在使用延迟求值的时候，表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。 简单来说，延迟加载就是指表达式只在必要时才求值，而非被赋给某个变量时立即求值。与惰性求值相对应的是及早求值，其维基百科定义如下。 及早求值（Eager evaluation）又译热切求值，也被称为贪婪求值（Greedy evaluation），是多数传统编程语言的求值策略。在及早求值中，表达式在它被约束到变量的时候就立即求值。这在简单编程语言中作为低层策略是更有效率的，因为不需要建造和管理表示未求值的表达式的中介数据结构。 二、延迟加载的好处与应用场景对于及早求值，对象在定义时便已获取，若后续逻辑并未使用该对象，则会造成资源浪费，降低运行效率。而惰性求值会在数据真正被调用时去获取，若后续未调用则不获取，避免计算开销，若后续调用多次，也可通过存储计算结果的方式来实现结果复用，避免多次计算。延迟加载流程图如下所示。 对于业务场景中计算开销较大的数据对象，若其在后续逻辑中可能会根据不同的业务判断条件在不同作用域中被使用多次，也可能一次都不会被使用到，那就可以使用延迟加载来获取该对象。 如上述代码举例，Heavy为计算开销较大的对象。 若采用立即加载，在某些特定业务条件下，conditionA与conditionB均为false，此时最终并未使用Heavy对象，则会造成资源浪费，若代码改为在各自条件的作用域中单独获取Heavy对象，则有可能造成重复获取，也会造成多余计算。 若采用延迟加载，当条件均不满足时，不会调用Heavy对象，此时也没有触发真正加载操作，当存在条件满足时，会在第一次调用对象时进行加载操作，后续如还需使用可复用该次加载结果，整个过程没有资源浪费。 三、延迟加载的实现Java语言中并没有直接的延迟加载方法，但在Java8中引入的lambda表达式以及Supplier等函数式接口为我们实现延迟操作提供了很大的便捷性。可以通过增加一个间接层来实现，相当于使用Proxy模式，利用Supplier定义计算逻辑，把耗资源的运算过程放入Supplier的get方法中，并在Proxy对象中持有该Supplier实例，由Proxy对象来维护目标对象的实际加载与结果缓存，并确保安全性（如线程安全等）。一种可行的实现方案如下所示。 其中Lazy即为外层Proxy对象，内部持有Supplier实例delegate，通过volatile和双重检验锁实现目标对象的单例效果，保证最多只加载一次，实现结果缓存复用，并确保多线程并发环境下的访问安全性。同时还提供了一系列便捷操作，如映射/扁平化映射/过滤等操作，且仍返回延迟对象，同样具有延迟加载效果，方便开发使用。 除了上述实现方案之外，延迟加载也可通过其它类似方式实现，例如下述代码，通过运行时改变内部Supplier变量的对象类型来判断是否已加载对象并返回，并采用synchronized同步方法来实现线程安全。 还有一种实现更为简便，代码如下所示，利用Java中ConcurrentHashMap本身的同步机制来实现线程安全。 参考 关于延迟加载的一些应用]]></content>
      <categories>
        <category>Java</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>延迟加载</tag>
        <tag>惰性求值</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Redis实现延时队列的优化方案]]></title>
    <url>%2Fposts%2F43502be6%2F</url>
    <content type="text"><![CDATA[本文结合项目中的实际需求介绍了延时队列的应用场景，简要描述了延时队列的多种实现，重点讲述redis实现延时队列的原理，并对其实现方案进行分析优化，并将最终方案实际运用于项目需求中。 一、延时队列的应用近期在开发部门的新项目，其中有个关键功能就是智能推送，即根据用户行为在特定的时间点向用户推送相应的提醒消息，比如以下业务场景： 在用户点击充值项后，半小时内未充值，向用户推送充值未完成提醒。 在用户最近一次阅读行为2小时后，向用户推送继续阅读提醒。 在用户新注册或退出应用N分钟后，向用户推送合适的推荐消息。 …… 上述场景的共同特征就是在某事件触发后延迟一定时间后再执行特定任务，若事件触发时间点可知，则上述逻辑也可等价于在指定时间点（事件触发时间点+延迟时间长度）执行特定任务。实现这类需求一般采用延时队列，其中创建的延时消息中需要包含任务延迟时间或任务执行时间点等信息，当任务满足时间条件需要执行时，该消息便会被消费，也就是说可以指定队列中的消息在哪个时间点被消费。 二、延时队列的实现在单机环境中，JDK已经自带了很多能够实现延时队列功能的组件，比如DelayQueue, Timer, ScheduledExecutorService等组件，都可以较为简便地创建延时任务，但上述组件使用一般需要把任务存储在内存中，服务重启存在任务丢失风险，且任务规模体量受内存限制，同时也造成长时间内存占用，并不灵活，通常适用于单进程客服端程序中或对任务要求不高的项目中。 在分布式环境下，仅使用JDK自带组件并不能可靠高效地实现延时队列，通常需要引入第三方中间件或框架。 比如常见的经典任务调度框架Quartz或基于此框架的xxl-job等其它框架，这些框架的主要功能是实现定时任务或周期性任务，在Redis、RabbitMQ还未广泛应用时，譬如常见的超时未支付取消订单等功能都是由定时任务实现的，通过定时轮询来判断是否已到达触发执行的时间点。但由于定时任务需要一定的周期性，周期扫描的间隔时间不好控制，太短会造成很多无意义的扫描，且增大系统压力，太长又会造成执行时间误差太大，且可能造成单次扫描所处理的堆积记录数量过大。 此外，利用MQ做延时队列也是一种常见的方式，比如通过RabbitMQ的TTL和死信队列实现消息的延迟投递，考虑到投递出去的MQ消息无法方便地实现删除或修改,即无法实现任务的取消或任务执行时间点的更改，同时也不能方便地对消息进行去重，因此在项目中并未选择使用MQ实现延时队列。 Redis的数据结构zset，同样可以实现延迟队列的效果，且更加灵活，可以实现MQ无法做到的一些特性，因此项目最终采用Redis实现延时队列，并对其进行优化与封装。 实现原理是利用zset的score属性，redis会将zset集合中的元素按照score进行从小到大排序，通过zadd命令向zset中添加元素，如下述命令所示，其中value值为延时任务消息，可根据业务定义消息格式，score值为任务执行的时间点，比如13位毫秒时间戳。 1zadd delayqueue 1614608094000 taskinfo 任务添加后，获取任务的逻辑只需从zset中筛选score值小于当前时间戳的元素，所得结果便是当前时间节点下需要执行的任务，通过zrangebyscore命令来获取，如下述命令所示，其中timestamp为当前时间戳，可用limit限制每次拉取的记录数，防止单次获取记录数过大。 1zrangebyscore delayqueue 0 timestamp limit 0 1000 在实际实现过程中，从zset中获取到当前需要执行的任务后，需要先确保将任务对应的元素从zset中删除，删除成功后才允许执行任务逻辑，这样是为了在分布式环境下，当存在多个线程获取到同一任务后，利用redis删除操作的原子性，确保只有一个线程能够删除成功并执行任务，防止重复执行。实际任务的执行通常会再将其发送至MQ异步处理，将“获取任务”与“执行任务”两者分离解耦，更加灵活，“获取任务”只负责拿到当前时间需要执行的任务，并不真正运行任务业务逻辑，因此只需相对少量的执行线程即可，而实际的任务执行逻辑则由MQ消费者承担，方便调控负载能力。整体过程如下图所示。 采用zset做延时队列的另一个好处是可以实现任务的取消和任务执行时间点的更改，只需要将任务信息从zset中删除，便可取消任务，同时由于zset拥有集合去重的特性，只需再次写入同一个任务信息，但是value值设置为不同的执行时间点，便可更改任务执行时间，实现单个任务执行时间的动态调整。 了解实现原理后，再进行具体编程实现。创建延时任务较为简便，准备好任务消息和执行时间点，写入zset即可。获取延时任务最简单的方案是通过定时任务，周期性地执行上述逻辑，如下代码所示。 123456789101112131415161718192021@XxlScheduled(cron = "0/5 * * * * ?", name = "scan business1 delayqueue")public void scanBusiness1() &#123; // 某业务逻辑的zset延迟队列对应的key String zsetKey = "delayqueue:business1"; while (true) &#123; // 筛选score值小于当前时间戳的元素，一次最多拉取1000条 Set&lt;String&gt; tasks = stringRedisTemplate.opsForZSet().rangeByScore(zsetKey, 0, System.currentTimeMillis(), 0, 1000); if (CollectionUtils.isEmpty(tasks)) &#123; // 当前时间下已没有需要执行的任务，结束本次扫描 return; &#125; for (String task : tasks) &#123; // 先删除，再执行，确保多线程环境下执行的唯一性 Boolean delete = stringRedisTemplate.delete(task); if (delete) &#123; // 删除成功后，将其再发送到指定MQ异步处理，将“获取任务”与“执行任务”分离解耦 rabbitTemplate.convertAndSend("exchange_business1", "routekey_business1", task); &#125; &#125; &#125;&#125; 上述方案使用xxl-job做分布式定时任务，间隔5秒执行一次，代码借助spring提供的api来完成redis和MQ的操作。由于是分布式定时任务，每次执行只有一个线程在获取任务，机器利用率低，当数据规模较大时，单靠一个线程无法满足吞吐量要求，因此这种方案只适用于小规模数据量级别。此处间隔时间也可适当调整，例如缩短为1秒，调整所需考虑原则在上文已提到：间隔太短会造成很多无意义的扫描，且增大系统压力，太长又会造成执行时间误差太大。 为了提升整体吞吐量，考虑不使用分布式定时任务，对集群内每台机器（或实例）均设置独立的定时任务，同时采用多个zset队列，以数字后缀区分。假设有M个zset队列，创建延时消息时选取消息的某个ID字段，计算hash值再对M取余，根据余数决定发送到对应数字后缀的zset队列中（分散消息，此处ID字段选取需要考虑做到均匀分布，不要造成数据倾斜）。队列数量M的选取需要考虑机器数量N，理想情况下有多少台机器就定义多少个队列，保持M与N基本相等即可。因为队列太少，会造成机器对队列的竞争访问处理，队列太多又会导致任务得不到及时的处理。最佳实践是队列数量可动态配置，如采用分布式配置中心，这样当集群机器数量变化时，可以相应调整队列数量。 每台机器在触发定时任务时，需要通过适当的负载均衡来决定从哪个队列拉取消息，负载均衡的好坏也会影响整个集群的效率，如果负载分布不均可能会导致多台机器竞争处理同一队列，降低效率。一个简单实用的做法是利用redis的自增操作再对队列数量取余即可，只要保持队列数量和机器数量基本相等，这种做法在很大程度上就可以保证不会有多台机器竞争同一队列。至于每台机器从对应zset中的任务获取逻辑，仍然和前面代码一致。以上方式简化实现代码如下所示。 123456789101112@Scheduled(cron = "0/5 * * * * ?")public void scanBusiness1() &#123; // 队列数量M，考虑动态配置，保持和机器数量基本一致 int M = 10; // redis自增key，用于负载均衡 String incrKey = "incrkey:delayqueue:business1"; // 每台机器执行时，从不同的zset中拉取消息，尽量确保不同机器访问不同zset String zsetKey = "delayqueue:business1:" + (stringRedisTemplate.opsForValue().increment(incrKey) % M); while (true) &#123; // 此处逻辑和前面代码一致，省略。。。 &#125;&#125; 上述方案和第一种方案的主要的不同点在于zsetKey的获取上，这里是根据负载均衡算法算出来的，确保每台机器访问不同zset并拉取消息，同时定时任务采用spring提供的进程内注解@Scheduled，集群内每台机器都会间隔5秒执行，因此相比之前的方案，能够较为明显地提升整个集群的吞吐量。但是这种方案的步骤相对更为复杂，需要动态配置队列数量，同时在创建延时任务时需要选择合适的消息ID字段来决定发送的目标zset队列，此处还要考虑均匀分布，整体实现要考虑的因素较多。 上面一种方案已经能够较好地满足整体吞吐量要求，但其缺点是步骤相对复杂，因此项目中没有采用这种方案，而是采用下面一种也能满足吞吐量要求，步骤相对简单，又方便通用化的方案。 该方案不使用定时任务，而是单独启动后台线程，在线程中执行永久循环，每次循环逻辑为：从目标zset中获取score值小于当前时间戳的元素集合中的score最小的那个元素，相当于获取当前时间点需要执行且执行时间点最早的那个任务，如果获取不到，表示当前时间点下暂无需要执行的任务，则线程休眠100ms（可视情况调整），否则，对获取到的元素进行处理，在分布式多线程环境下，仍然需要先删除成功才能进行处理。此外，考虑到每个线程获取元素后都需要再次访问redis尝试删除操作，为了避免多线程争抢浪费资源，降低效率，这里采用lua脚本将获取和删除操作原子化。lua脚本逻辑代码如下所示。 123456789local zsetKey = 'delayqueue'local timestamp = 1614608094000local items = redis.call('zrangebyscore',zsetKey,0,timestamp,'limit',0,1)if #items == 0 then return ''else redis.call('zremrangebyrank',zsetKey,0,0) return items[1]end 其中timestamp为当前时间戳，通过在zrangebyscore命令中指定limit为1来获取score最小的元素，若获取不到，即结果集长度为0，则返回空字符串，否则，通过zremrangebyrank命令删除头部元素，即score最小的元素，也就是之前获取到的那个元素，由于redis内部保证lua脚本的原子性，上述获取并删除的操作能够运行无误。具体JAVA实现中还对其进行了多线程操作的封装和通用化的抽象，使不同业务都能够使用该组件实现延时队列。具体实现代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 基于ZSET实现消息延迟处理，score存储执行时间点，到达时间点即会向指定队列发送该消息； * 定义一个继承本类的bean即可； */public abstract class AbstractDelayedMsgScanTrigger implements Runnable, DisposableBean &#123; private static final RedisScript&lt;String&gt; TRY_GET_AND_DEL_SCRIPT; static &#123; // 获取并删除的lua脚本，使用spring提供的api String sb = "local items = redis.call('zrangebyscore',KEYS[1],0,ARGV[1],'limit',0,1)\n" + "if #items == 0 then\n" + "\treturn ''\n" + "else\n" + "\tredis.call('zremrangebyrank',KEYS[1],0,0)\n" + "\treturn items[1]\n" + "end"; // 自有工具类，只要能创建出spring包下的 RedisScript 的实现类对象均可 TRY_GET_AND_DEL_SCRIPT = RedisScriptHelper.createScript(sb, String.class); &#125; private final ThreadPoolExecutor EXECUTOR = new ThreadPoolExecutor(getThreadNum(), getThreadNum(), 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(), new NamedThreadFactory(getThreadNamePrefix())); private volatile boolean quit = false; @Autowired private StringRedisTemplate stringRedisTemplate; @Autowired private RabbitTemplate rabbitTemplate; @PostConstruct public void startScan() &#123; // bean构建完成后，启动若干执行线程 int threadNum = getThreadNum(); for (int i = 0; i &lt; threadNum; i++) &#123; EXECUTOR.execute(this); &#125; &#125; @Override public void run() &#123; while (!quit) &#123; try &#123; // 循环，采用lua获取当前需要执行的任务并将其从redis中删除 String msg = stringRedisTemplate.execute(TRY_GET_AND_DEL_SCRIPT, Lists.newArrayList(getDelayedMsgSourceKey()), String.valueOf(System.currentTimeMillis())); if (StringUtils.isNotBlank(msg)) &#123; // 消息不为空，表示获取任务成功，将其再发送到指定MQ异步处理，将“获取任务”与“执行任务”分离解耦 rabbitTemplate.convertAndSend(getSendExchange(), getSendRoutingKey(), msg); &#125; else &#123; // 获取不到任务，表示当前时间点下暂无需要执行的任务，则线程休眠1S（可视情况调整） SleepUtils.sleepSeconds(1); &#125; &#125; catch (Exception e) &#123; Logs.MSG.error("delayed msg scan error, sourceKey:&#123;&#125;", getDelayedMsgSourceKey(), e); &#125; &#125; &#125; @Override public void destroy() throws Exception &#123; quit = true; &#125; public void setQuit(boolean quit) &#123; this.quit = quit; &#125; /** * 获取消息的工作线程数量 */ protected abstract int getThreadNum(); /** * 线程名称前缀，方便问题定位 */ protected abstract String getThreadNamePrefix(); /** * 存放延迟消息的ZSET队列名 */ protected abstract String getDelayedMsgSourceKey(); /** * 消息到达执行时间点时将其通过指定 exchange 发送到实时消费队列中 */ protected abstract String getSendExchange(); /** * 消息到达执行时间点时将其通过指定 routingKey 发送到实时消费队列中 */ protected abstract String getSendRoutingKey();&#125; 在具体业务应用中，只需定义一个继承上述类的bean即可，需要实现的方法主要是提供一些配置，比如该业务对应的zset延时队列名称，同时工作拉取消息的线程数量，由于采用rabbitMq，因此这里需要提供exchange和routingKey。实际使用中只需向该zset队列中添加消息，并将score设为该任务需要执行的时间点（此处为13位毫秒时间戳），则到该时间点后，上述组件便会将该消息从zset中取出并删除，再将其通过指定的路由发送到实时MQ消费队列中，由消费者负责执行任务业务逻辑。目前该组件在项目中正常平稳运行。 三、总结本文结合项目中的实际需求介绍了延时队列的应用场景，分析了延时队列的多种实现，重点讲述了利用redis实现延时队列的原理，对其实现方案进行比较与优化，并将最终方案实际运用于项目需求中。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>延时队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 行为型]]></title>
    <url>%2Fposts%2Fef6a83ef%2F</url>
    <content type="text"><![CDATA[行为型设计模式简介。 行为型设计模式行为型模式(Behavioral Pattern)关注对象之间的通信。其不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用，以及对在不同的对象之间划分责任和算法的抽象化。通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。行为型模式分为类行为型模式和对象行为型模式两种： 类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。 对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。 策略模式定义算法家族，分别封装，可以相互替换，让算法的变化不影响使用算法的客户。1个抽象算法类；n个具体算法类；1个上下文，包含1个抽象算法类成员变量，用于维护1个具体算法类对象，并提供1个上下文接口方法，在其内部调用抽象算法类接口方法。可以和简单工厂相结合，在上下文的构造方法中传入不同标识，由此给内部的抽象算法类成员变量创建不同的具体算法类对象。 策略模式 观察者模式（发布-订阅模式）定义一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。Java类库：Observer（观察者接口）和Observable（被观察者类，主题）。对比：事件驱动模式，事件源/事件/监听器。 观察者模式 迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。Java集合类库：Iterable, Iterator, 迭代器作为集合内部类实现，有效利用集合内部状态，并隐藏实现细节。foreach语法：数组、Iterable接口实现类。 迭代器模式 职责链模式使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，沿着该链传递该请求，直到有一个对象处理它为止。客户端与具体的处理者解耦，客户端只认识一个Hanlder接口，降低了客户端（即请求发送者）与处理者的耦合度。客户端和处理者都不关心职责链的具体结构，而是交给职责链的创造者，也正因为如此，当在职责链中添加处理者的时候，这对客户端和处理者来说，都是透明的，二者不知道也不必要知道职责链的变化。 职责链模式 模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法模式通过把不变行为搬移到超类，去除子类中的重复代码来体现代码复用。为了不强制子类实现不必要的抽象方法，但又不剥夺子类自由选择的权利，我们可以在抽象父类提供一个默认的空实现，来让子类自由选择是否要覆盖掉这些方法。Java应用举例：类加载器ClassLoader定义好查找类的算法，保证双亲委派机制 模板方法模式 访问者模式表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。元素：数据结构，接受访问者访问者：作用于数据结构上的操作、算法，分别实现每一种具体元素的访问操作对象结构：一个抽象表述，可理解为具有容器性质或者复合对象特性的类，含有一组元素，并且可以迭代这些元素，供访问者访问。将数据结构和作用于结构上的操作解耦合，适用于数据结构相对稳定算法又易变化的系统。倾斜的开闭原则：增加操作（访问者）容易，符合开闭原则，此为优点；增加新的数据结构（元素）困难，会破坏开闭原则，此为缺点。通过两次动态单分派（动态多态）实现伪动态双分派（Java是静态多分派、动态单分派语言）。进一步，可以将元素提炼出层次结构，针对层次结构提供操作的方法，能够实现针对层次定义操作以及跨越层次定义操作。 访问者模式 命令模式将一个请求封装为一个对象，从而使你可用不同的请求对象对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。在软件系统中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，需要将“行为请求者”与“行为实现者”解耦，可以将一组行为抽象为对象，实现二者之间的松耦合。类比：需求方client——产品经理invoker——程序员receiver，需求/bug/问题相当于command 命令模式 状态模式当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。控制对象状态的条件表达式过于复杂，把状态的判断逻辑转移到表示不同状态的一系列类中，简化复杂的判断逻辑。结构上与策略模式相似。 状态模式 解释器模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的文字。上下文无关文法：终结符、非终结符、规则集合、起始符号（非终结符号集的一个元素） 解释器模式 中介者模式用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。解决一系列对象之间复杂的耦合关系，往往是“多对多”耦合关系，采用一个中介者对象将这一系列对象集中管理，而各个对象也将自己与其它对象的交互行为委托给中介者处理，从而减少这一系列对象之间的耦合。 中介者模式 备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。该对象可以借此恢复到原先保存的状态。发起者：创建包含自身状态的一份备忘录，可通过备忘录恢复自身状态；备忘录：保存发起者的某一时刻的内部状态；管理者：保存、管理备忘录；优点：发起者无需管理自己的状态，备份到外部，可以给外部提供一个操作该对象内部状态的接口，保持封装的边界。缺点：备忘录信息所占用资源可能较大，管理者无法预知备份的信息大小。 备忘录模式 参考 《大话设计模式》 设计模式大杂烩（24种设计模式的总结以及学习设计模式的几点建议）- 左潇龙]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 结构型]]></title>
    <url>%2Fposts%2F5f8379c7%2F</url>
    <content type="text"><![CDATA[结构型设计模式简介。 结构型设计模式结构型模式(Structural Pattern)关注类和对象的组合。其描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。结构型模式可以分为类结构型模式和对象结构型模式： 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承和实现关系。 对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。 代理模式为其他对象提供一种代理以控制对这个对象的访问。静态代理（结构上类似装饰器）：例如数据库连接池不真正关闭连接，可用静态代理；动态代理：例如Java中基于接口的动态代理，Proxy, InvocationHandler, 本质上是先生成class文件再加载生成类，该生成类继承Proxy类并实现入参接口数组中的各个接口，该类持有入参InvocationHandler实例以及接口数组的所有Method对象。 代理模式 装饰器模式不必改变原类文件和使用继承的情况下，动态扩展一个对象的功能，动态给一个对象添加一些额外的职责，做代码增强。就增加功能来说，装饰模式比生成子类更加灵活。也可以叫做“复合”设计。举例：对HttpRequest进行装饰，增加字符编码、过滤敏感词、HTML转义等功能；JAVA IO体系，其中的FilterInputStream即是装饰基类。 装饰器模式 适配器模式将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。实现方式区分：类适配器和对象适配器。使用目的区分：特殊适配器和缺省适配器。 适配器模式 外观模式为子系统的一组接口提供一个一致的界面，此模式定义了一个高层接口，该接口使得这一子系统更加容易使用。 实际使用当中，接口并不是必须的，虽说根据依赖倒置原则，无论是处于高层的外观层，还是处于底层的子系统，都应该依赖于抽象，但是这会倒置子系统的每一个实现都要对应一个接口，从而导致系统的复杂性增加，所以这样做并不是必须的。 外观接口当中并不一定是子系统中某几个功能的组合，也可以是将子系统中某一个接口的某一功能单独暴露给客户端。 外观接口如果需要暴露给客户端很多的功能的话，可以将外观接口拆分为若干个外观接口，如此便会形成一层外观层。外观模式 桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。抽象与实现之间的聚合。在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化，可以用桥接模式来应对这种“多维度的变化”，一个维度一个接口，并聚合于最外层抽象中。 桥接模式 组合模式将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。树形结构：比如文件系统，对叶子节点和非叶子节点定义统一的操作，客户端无需关心底层具体实现。 组合模式 享元模式运用共享技术有效地支持大量细粒度的对象。它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。通常物件中的部分状态是可以分享的，称为内部状态，相对的，外部状态则是随外部环境而变化的状态，是无法共享的状态。享元工厂用于提供可以共享的封装内部状态的对象。 享元模式 参考 《大话设计模式》 设计模式大杂烩（24种设计模式的总结以及学习设计模式的几点建议）- 左潇龙]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 创建型]]></title>
    <url>%2Fposts%2Fd69916f0%2F</url>
    <content type="text"><![CDATA[创建型设计模式简介。 创建型设计模式 创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。 创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象，这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 简单工厂模式1个抽象类或接口；n个实现类；1个工厂类根据不同输入标识new不同实现类对象。简便易用、但不符合开闭原则。可以考虑用注解消除elseif。 简单工厂模式 工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。工厂方法实现时，客户端需要决定实例化哪一个工厂来实现运算类。将简单工厂模式中的工厂类变为一个工厂抽象接口和多个具体生成对象的工厂。工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。若想增加功能，简单工厂模式要修改工厂类，工厂方法需要增加新的工厂实现类以及改客户端。符合开闭原则。应用举例：JDBC中Driver和Connection；集合框架中Iterable和Iterator 工厂方法模式 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口（抽象工厂接口中的createXXX方法），而无需指定它们具体的类。在工厂方法基础上增加多种产品。应用举例：JDK集合框架中，两个产品：Iterator和ListIterator，工厂接口：List，具体工厂类：LinkedList和ArrayList 抽象工厂模式 单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。对唯一实例的受控访问。懒汉式，需要考虑线程安全：使用双重检验锁DCL，判断两次实例是否存在，加一次锁，同时将instance声明为volatile，禁止指令重排序。饿汉式，static final field内部类（推荐）、枚举（防止反序列化） 单例模式 原型模式从一个对象再创建另外一个可定制的对象，不需要知道创建的细节。Cloneable接口。初始化信息不发生变化的情况下，克隆是创建对象最好的方式，既隐藏对象创建的细节，又对性能大大提高（不用执行new方法）。Cloneable, clone(),深复制、浅复制。 原型模式 建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。1个建造者接口，定义建造的各个步骤；n个具体建造者，实现接口，构建和装配具体的产品；1个指挥者聚合一个建造者，指挥建造过程。常见的一种使用方式可以去除Builder和Director，由Client充当Director角色，同时ConcreteBuilder作为Product的静态内部类。 建造者模式 参考 《大话设计模式》 设计模式大杂烩（24种设计模式的总结以及学习设计模式的几点建议）- 左潇龙]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象与设计模式原则]]></title>
    <url>%2Fposts%2F5f144119%2F</url>
    <content type="text"><![CDATA[面向对象思想与设计模式原则。 面向对象 面向对象与设计模式旨在构建可维护、可扩展、可复用、灵活性好的软件应用程序。 类是对对象的抽象；抽象类是对类的抽象；接口是对行为的抽象。 抽象类是自底而上抽象出来的；接口是自顶向下设计出来的。 设计模式原则 开闭原则（Open Close Principle）定义：软件实体（类、模块、函数等）可以扩展，不可修改。对扩展开放，对修改关闭。面对需求变化，对程序的改动是通过增加新代码进行，而不是更改现有代码。实现热插拔的效果，使程序具有更好的扩展性，易于维护和升级。想要达到这样的效果，需要使用接口和抽象类。仅对程序中呈现出频繁变化的那些部分作出抽象，对每个部分都刻意进行抽象不是个好主意。拒绝不成熟的抽象和抽象本身一样重要。 里氏代换原则（Liskov Substitution Principle）定义：所有引用基类的地方必须能透明地使用其子类的对象。里氏代换原则是面向对象设计的基本原则之一。 任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。侧重于子类不应该重写父类方法，但是很多实际场景是不符合的，许多设计模式本身也不符合这个原则。 依赖倒转原则（Dependence Inversion Principle）定义：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。这个原则是开闭原则的基础。针对接口编程，不针对实现编程。依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle）定义：一个类对另一个类的依赖应该建立在最小的接口上。接口最小化，使用多个隔离的接口，比使用单个接口要好，降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 迪米特法则，又称最少知道原则（Demeter Principle）定义：一个软件实体应当尽可能少地与其他实体发生相互作用，使得系统功能模块相对独立。一个实体不应该依赖于其它实体太多细节。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。强调类之间的松耦合，类似面向接口编程。 单一职责原则（Single responsibility principle）定义：就一个类而言，应该仅有一个引起它变化的原因。每个类尽量只负责单一功能，高内聚。 另：合成复用原则（Composite Reuse Principle）尽量使用组合/聚合的方式，而不是使用继承。 参考 《大话设计模式》 设计模式详解（总纲）- 左潇龙]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql被黑客入侵及安全措施总结]]></title>
    <url>%2Fposts%2Fd82d4f3e%2F</url>
    <content type="text"><![CDATA[一次Mysql服务器被黑客攻击的不幸遭遇。 情况概述今天登陆在腾讯云服务器上搭建的Mysql数据库，发现数据库被黑了，黑客提示十分明显。Mysql中只剩下两个数据库，一个是information_schema，另一个是黑客创建的PLEASE_READ，其中有一张info表，内容如下： Info: Your DB is Backed up at our servers, to restore send 0.2 BTC to the Bitcoin Address then send an email with your server ip Bitcoin_Address: 1F33LEJjdphD6YpaonNCHejwLcgkgDGQW9 Email: mysqldata@mail2tor.com 显然，我这是遇到比特币敲诈了。我的数据在别人的服务器里安然的躺着，需要向黑客支付0.2比特币才有可能恢复。按照当前的汇率，0.2比特币大约为1400人民币，这是我第一次遇到网络敲诈，金额还不小。所幸数据库里并没有值钱的数据，就当是送给黑客了，不过 数据库安全问题 引起了我的注意。 安全措施由于缺乏必要的安全措施和备份机制，数据库中原有的数据均已丢失。为了恢复到Mysql初始的状态，重新安装了Mysql数据库，并且重新创建原先存在的数据库，同时，为了防止再次被黑客入侵，对Mysql进行了一些安全配置。 禁用或限制远程访问。若允许远程访问，需要确保特定主机才拥有访问权。 对用户进行合理授权，应用程序中最好不要直接使用root用户。 限制打开网络socket，此时仍可以建立与Mysql服务器的本地连接。 12[mysqld]skip-networking 强迫Mysql仅监听本机。 12[mysqld]bind-address=127.0.0.1 更改root用户的登录名称和密码。 移除测试数据库和匿名账户及废弃的账户。 禁用LOCAL INFILE。 12[mysqld]set-variable=local-infile=0 删除历史命令记录。 12cat /dev/null &gt; ~/.bash_historycat /dev/null &gt; ~/.mysql_history 及时安装Mysql安全补丁。 使用chroot限制Mysql运行环境。 自动定期备份数据库。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebsphereMQ V8 解决客户机连接报2035错误码]]></title>
    <url>%2Fposts%2F46226b28%2F</url>
    <content type="text"><![CDATA[本文介绍应用程序与WebsphereMQ连接的两种模式，以及对客户机连接模式下报2035错误码给出解决方法。 连接模式应用程序与MQ服务器端的连接模式有两种：本地绑定 和 客户机连接。本地绑定模式仅适用于应用程序和MQ服务器运行在同一台机器上，而客户机连接模式则没有此限制，可用于两者运行在不同机器或同一台机器上。不过当应用程序和和MQ 服务器运行于同一台机器上时，一般推荐使用本地绑定模式，该模式下两者通过进程间通讯 (IPC) 协议进行通信，传输效率较高，且不受网络状况影响。 本地绑定模式配置比较简单，一般情况下，只要在应用程序中提供队列管理器名称，即可连接到本地MQ服务器上的队列管理器上，不需要提供MQ服务器主机名，监听端口和服务器连接通道名称。 客户机连接模式比本地绑定模式配置稍微复杂，需要在MQ服务器中创建服务器连接通道，注意此处的通道类型为服务器连接通道，该通道名称需要在应用程序中配置，比如配置在MQEnvironment.channel属性中，此外还需要配置队列管理器所在的主机名，监听端口。 解决客户机连接报2035错误码本地绑定模式的连接一般不会出什么问题，而在客户机连接模式时可能出现MQRC_NOT_AUTHORIZED - 2035错误，解决这个问题需要注意以下几点。 队列管理器是否开启通道认证记录通道认证记录用来允许或阻止客户端应用程序对MQ队列管理器的连接，如果开启了，则需要保证当前的通道认证记录中的配置项允许你的应用程序通过你选定的服务器连接通道进行连接。常见的认证规则可以通过用户名、IP地址等进行允许或阻止连接的控制，具体的配置方法这里不作详述，需要注意的是队列管理器内置的系统对象，包括各种通道和通道认证记录，可以通过下图所示方式在MQ Explorer查看。如果你使用的是队列管理器内置的服务器连接通道，比如SYSTEM.DEF.SVRCONN，则需要考虑内置的通道认证记录，比如默认的SYSTEM.* 配置禁用了所有的系统通道，可以将该配置项删除，也可以修改该配置项。 队列管理器内置的各种系统通道 队列管理器内置的通道认证记录 关于通道认证记录所造成的访问问题，最简单直接的方式便是将通道认证记录功能关闭，不过这样也就失去了对客户应用程序的连接授权控制。可以通过命令行指令关闭通道认证记录。 12RUNMQSC 队列管理器名称ALTER QMGR CHLAUTH(DISABLED) 也可以通过MQ Explorer关闭。 注意服务器连接通道的MCAUSER（MCA用户标识）属性该属性表示通过该通道连接的应用程序在和队列管理器进行通信时所使用的用户名称，其值必须为MQ服务器上的mqm组内的用户，否则便会出现2035错误。需要注意，如果MCAUSER为空，则使用运行MQ应用程序所在的操作系统上的用户名称；如果MCAUSER不为空，则使用该值作为应用程序连接通道时使用的用户名称。 可以通过命令行指令修改： 12RUNMQSC 队列管理器名称ALTER CHL(通道名) CHLTYPE(SVRCONN) MCAUSER('指定的用户标识') V8版本与服务器连接默认需要密码认证网上很多资料关于解决2035错误的方法都是对于Websphere MQ V7.x 的，我使用的是V8.0，使用网上的解决方法仍然会报2035错误，后来发现在V8.0中需要多注意一个配置才能解决2035错误。参考：http://stackoverflow.com/questions/25911557/websphere-mq-v8-mqrc-not-authorized-2035。 在V8中，与服务器的连接默认需要密码去认证，可以通过配置队列管理器的连接认证选项来解决。 通过以下命令行指令，将连接认证选项中的SYSTEM.DEFAULT.AUTHINFO.IDPWOS的属性配置为OPTIONAL。 1ALTER AUTHINFO(SYSTEM.DEFAULT.AUTHINFO.IDPWOS) AUTHTYPE(IDPWOS) CHCKCLNT(OPTIONAL) 或者直接将连接认证选项置为空，将其完全关闭，指令如下. 1ALTER QMGR CONNAUTH('') 在执行完上述两条命令中的任一条后，都需要刷新连接认证的缓存，指令如下。 1REFRESH SECURITY TYPE(CONNAUTH) 除了上面两种命令行方式，也可以通过MQ Explorer关闭连接认证，如下图，在队列管理器的扩展属性中将连接认证一栏置为空即可。 通过以上注意点，一般可以解决连接MQ服务器的2035错误。]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>WebsphereMQ</tag>
      </tags>
  </entry>
</search>
