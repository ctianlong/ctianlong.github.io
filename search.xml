<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式 - 结构型]]></title>
    <url>%2Fposts%2F5f8379c7%2F</url>
    <content type="text"><![CDATA[结构型设计模式简介。 结构型设计模式结构型模式(Structural Pattern)关注类和对象的组合。其描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。结构型模式可以分为类结构型模式和对象结构型模式： 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承和实现关系。 对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。 代理模式为其他对象提供一种代理以控制对这个对象的访问。静态代理（结构上类似装饰器）：例如数据库连接池不真正关闭连接，可用静态代理；动态代理：例如Java中基于接口的动态代理，Proxy, InvocationHandler, 本质上是先生成class文件再加载生成类，该生成类继承Proxy类并实现入参接口数组中的各个接口，该类持有入参InvocationHandler实例以及接口数组的所有Method对象。 代理模式 装饰器模式不必改变原类文件和使用继承的情况下，动态扩展一个对象的功能，动态给一个对象添加一些额外的职责，做代码增强。就增加功能来说，装饰模式比生成子类更加灵活。也可以叫做“复合”设计。举例：对HttpRequest进行装饰，增加字符编码、过滤敏感词、HTML转义等功能；JAVA IO体系，其中的FilterInputStream即是装饰基类。 装饰器模式 适配器模式将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。实现方式区分：类适配器和对象适配器。使用目的区分：特殊适配器和缺省适配器。 适配器模式 外观模式为子系统的一组接口提供一个一致的界面，此模式定义了一个高层接口，该接口使得这一子系统更加容易使用。 实际使用当中，接口并不是必须的，虽说根据依赖倒置原则，无论是处于高层的外观层，还是处于底层的子系统，都应该依赖于抽象，但是这会倒置子系统的每一个实现都要对应一个接口，从而导致系统的复杂性增加，所以这样做并不是必须的。 外观接口当中并不一定是子系统中某几个功能的组合，也可以是将子系统中某一个接口的某一功能单独暴露给客户端。 外观接口如果需要暴露给客户端很多的功能的话，可以将外观接口拆分为若干个外观接口，如此便会形成一层外观层。外观模式 桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。抽象与实现之间的聚合。在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化，可以用桥接模式来应对这种“多维度的变化”，一个维度一个接口，并聚合于最外层抽象中。 桥接模式 组合模式将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。树形结构：比如文件系统，对叶子节点和非叶子节点定义统一的操作，客户端无需关心底层具体实现。 组合模式 享元模式运用共享技术有效地支持大量细粒度的对象。它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。通常物件中的部分状态是可以分享的，称为内部状态，相对的，外部状态则是随外部环境而变化的状态，是无法共享的状态。享元工厂用于提供可以共享的封装内部状态的对象。 享元模式 参考 《大话设计模式》 设计模式大杂烩（24种设计模式的总结以及学习设计模式的几点建议）- 左潇龙]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 创建型]]></title>
    <url>%2Fposts%2Fd69916f0%2F</url>
    <content type="text"><![CDATA[创建型设计模式简介。 创建型设计模式 创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。 创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象，这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 简单工厂模式1个抽象类或接口；n个实现类；1个工厂类根据不同输入标识new不同实现类对象。简便易用、但不符合开闭原则。可以考虑用注解消除elseif。 简单工厂模式 工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。工厂方法实现时，客户端需要决定实例化哪一个工厂来实现运算类。将简单工厂模式中的工厂类变为一个工厂抽象接口和多个具体生成对象的工厂。工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。若想增加功能，简单工厂模式要修改工厂类，工厂方法需要增加新的工厂实现类以及改客户端。符合开闭原则。应用举例：JDBC中Driver和Connection；集合框架中Iterable和Iterator 工厂方法模式 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口（抽象工厂接口中的createXXX方法），而无需指定它们具体的类。在工厂方法基础上增加多种产品。应用举例：JDK集合框架中，两个产品：Iterator和ListIterator，工厂接口：List，具体工厂类：LinkedList和ArrayList 抽象工厂模式 单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。对唯一实例的受控访问。懒汉式，需要考虑线程安全：使用双重检验锁DCL，判断两次实例是否存在，加一次锁，同时将instance声明为volatile，禁止指令重排序。饿汉式，static final field内部类（推荐）、枚举（防止反序列化） 单例模式 原型模式从一个对象再创建另外一个可定制的对象，不需要知道创建的细节。Cloneable接口。初始化信息不发生变化的情况下，克隆是创建对象最好的方式，既隐藏对象创建的细节，又对性能大大提高（不用执行new方法）。Cloneable, clone(),深复制、浅复制。 原型模式 建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。1个建造者接口，定义建造的各个步骤；n个具体建造者，实现接口，构建和装配具体的产品；1个指挥者聚合一个建造者，指挥建造过程。常见的一种使用方式可以去除Builder和Director，由Client充当Director角色，同时ConcreteBuilder作为Product的静态内部类。 建造者模式 参考 《大话设计模式》 设计模式大杂烩（24种设计模式的总结以及学习设计模式的几点建议）- 左潇龙]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象与设计模式原则]]></title>
    <url>%2Fposts%2F5f144119%2F</url>
    <content type="text"><![CDATA[面向对象思想与设计模式原则。 面向对象 面向对象与设计模式旨在构建可维护、可扩展、可复用、灵活性好的软件应用程序。 类是对对象的抽象；抽象类是对类的抽象；接口是对行为的抽象。 抽象类是自底而上抽象出来的；接口是自顶向下设计出来的。 设计模式原则 开闭原则（Open Close Principle）定义：软件实体（类、模块、函数等）可以扩展，不可修改。对扩展开放，对修改关闭。面对需求变化，对程序的改动是通过增加新代码进行，而不是更改现有代码。实现热插拔的效果，使程序具有更好的扩展性，易于维护和升级。想要达到这样的效果，需要使用接口和抽象类。仅对程序中呈现出频繁变化的那些部分作出抽象，对每个部分都刻意进行抽象不是个好主意。拒绝不成熟的抽象和抽象本身一样重要。 里氏代换原则（Liskov Substitution Principle）定义：所有引用基类的地方必须能透明地使用其子类的对象。里氏代换原则是面向对象设计的基本原则之一。 任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。侧重于子类不应该重写父类方法，但是很多实际场景是不符合的，许多设计模式本身也不符合这个原则。 依赖倒转原则（Dependence Inversion Principle）定义：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。这个原则是开闭原则的基础。针对接口编程，不针对实现编程。依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle）定义：一个类对另一个类的依赖应该建立在最小的接口上。接口最小化，使用多个隔离的接口，比使用单个接口要好，降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 迪米特法则，又称最少知道原则（Demeter Principle）定义：一个软件实体应当尽可能少地与其他实体发生相互作用，使得系统功能模块相对独立。一个实体不应该依赖于其它实体太多细节。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。强调类之间的松耦合，类似面向接口编程。 单一职责原则（Single responsibility principle）定义：就一个类而言，应该仅有一个引起它变化的原因。每个类尽量只负责单一功能，高内聚。 另：合成复用原则（Composite Reuse Principle）尽量使用组合/聚合的方式，而不是使用继承。 参考 《大话设计模式》 设计模式详解（总纲）- 左潇龙]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql被黑客入侵及安全措施总结]]></title>
    <url>%2Fposts%2Fd82d4f3e%2F</url>
    <content type="text"><![CDATA[一次Mysql服务器被黑客攻击的不幸遭遇。 情况概述今天登陆在腾讯云服务器上搭建的Mysql数据库，发现数据库被黑了，黑客提示十分明显。Mysql中只剩下两个数据库，一个是information_schema，另一个是黑客创建的PLEASE_READ，其中有一张info表，内容如下： Info: Your DB is Backed up at our servers, to restore send 0.2 BTC to the Bitcoin Address then send an email with your server ip Bitcoin_Address: 1F33LEJjdphD6YpaonNCHejwLcgkgDGQW9 Email: mysqldata@mail2tor.com 显然，我这是遇到比特币敲诈了。我的数据在别人的服务器里安然的躺着，需要向黑客支付0.2比特币才有可能恢复。按照当前的汇率，0.2比特币大约为1400人民币，这是我第一次遇到网络敲诈，金额还不小。所幸数据库里并没有值钱的数据，就当是送给黑客了，不过 数据库安全问题 引起了我的注意。 安全措施由于缺乏必要的安全措施和备份机制，数据库中原有的数据均已丢失。为了恢复到Mysql初始的状态，重新安装了Mysql数据库，并且重新创建原先存在的数据库，同时，为了防止再次被黑客入侵，对Mysql进行了一些安全配置。 禁用或限制远程访问。若允许远程访问，需要确保特定主机才拥有访问权。 对用户进行合理授权，应用程序中最好不要直接使用root用户。 限制打开网络socket，此时仍可以建立与Mysql服务器的本地连接。 12[mysqld]skip-networking 强迫Mysql仅监听本机。 12[mysqld]bind-address=127.0.0.1 更改root用户的登录名称和密码。 移除测试数据库和匿名账户及废弃的账户。 禁用LOCAL INFILE。 12[mysqld]set-variable=local-infile=0 删除历史命令记录。 12cat /dev/null &gt; ~/.bash_historycat /dev/null &gt; ~/.mysql_history 及时安装Mysql安全补丁。 使用chroot限制Mysql运行环境。 自动定期备份数据库。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebsphereMQ V8 解决客户机连接报2035错误码]]></title>
    <url>%2Fposts%2F46226b28%2F</url>
    <content type="text"><![CDATA[本文介绍应用程序与WebsphereMQ连接的两种模式，以及对客户机连接模式下报2035错误码给出解决方法。 连接模式应用程序与MQ服务器端的连接模式有两种：本地绑定 和 客户机连接。本地绑定模式仅适用于应用程序和MQ服务器运行在同一台机器上，而客户机连接模式则没有此限制，可用于两者运行在不同机器或同一台机器上。不过当应用程序和和MQ 服务器运行于同一台机器上时，一般推荐使用本地绑定模式，该模式下两者通过进程间通讯 (IPC) 协议进行通信，传输效率较高，且不受网络状况影响。 本地绑定模式配置比较简单，一般情况下，只要在应用程序中提供队列管理器名称，即可连接到本地MQ服务器上的队列管理器上，不需要提供MQ服务器主机名，监听端口和服务器连接通道名称。 客户机连接模式比本地绑定模式配置稍微复杂，需要在MQ服务器中创建服务器连接通道，注意此处的通道类型为服务器连接通道，该通道名称需要在应用程序中配置，比如配置在MQEnvironment.channel属性中，此外还需要配置队列管理器所在的主机名，监听端口。 解决客户机连接报2035错误码本地绑定模式的连接一般不会出什么问题，而在客户机连接模式时可能出现MQRC_NOT_AUTHORIZED - 2035错误，解决这个问题需要注意以下几点。 队列管理器是否开启通道认证记录通道认证记录用来允许或阻止客户端应用程序对MQ队列管理器的连接，如果开启了，则需要保证当前的通道认证记录中的配置项允许你的应用程序通过你选定的服务器连接通道进行连接。常见的认证规则可以通过用户名、IP地址等进行允许或阻止连接的控制，具体的配置方法这里不作详述，需要注意的是队列管理器内置的系统对象，包括各种通道和通道认证记录，可以通过下图所示方式在MQ Explorer查看。如果你使用的是队列管理器内置的服务器连接通道，比如SYSTEM.DEF.SVRCONN，则需要考虑内置的通道认证记录，比如默认的SYSTEM.* 配置禁用了所有的系统通道，可以将该配置项删除，也可以修改该配置项。 队列管理器内置的各种系统通道 队列管理器内置的通道认证记录 关于通道认证记录所造成的访问问题，最简单直接的方式便是将通道认证记录功能关闭，不过这样也就失去了对客户应用程序的连接授权控制。可以通过命令行指令关闭通道认证记录。 12RUNMQSC 队列管理器名称ALTER QMGR CHLAUTH(DISABLED) 也可以通过MQ Explorer关闭。 注意服务器连接通道的MCAUSER（MCA用户标识）属性该属性表示通过该通道连接的应用程序在和队列管理器进行通信时所使用的用户名称，其值必须为MQ服务器上的mqm组内的用户，否则便会出现2035错误。需要注意，如果MCAUSER为空，则使用运行MQ应用程序所在的操作系统上的用户名称；如果MCAUSER不为空，则使用该值作为应用程序连接通道时使用的用户名称。 可以通过命令行指令修改： 12RUNMQSC 队列管理器名称ALTER CHL(通道名) CHLTYPE(SVRCONN) MCAUSER('指定的用户标识') V8版本与服务器连接默认需要密码认证网上很多资料关于解决2035错误的方法都是对于Websphere MQ V7.x 的，我使用的是V8.0，使用网上的解决方法仍然会报2035错误，后来发现在V8.0中需要多注意一个配置才能解决2035错误。参考：http://stackoverflow.com/questions/25911557/websphere-mq-v8-mqrc-not-authorized-2035。 在V8中，与服务器的连接默认需要密码去认证，可以通过配置队列管理器的连接认证选项来解决。 通过以下命令行指令，将连接认证选项中的SYSTEM.DEFAULT.AUTHINFO.IDPWOS的属性配置为OPTIONAL。 1ALTER AUTHINFO(SYSTEM.DEFAULT.AUTHINFO.IDPWOS) AUTHTYPE(IDPWOS) CHCKCLNT(OPTIONAL) 或者直接将连接认证选项置为空，将其完全关闭，指令如下. 1ALTER QMGR CONNAUTH('') 在执行完上述两条命令中的任一条后，都需要刷新连接认证的缓存，指令如下。 1REFRESH SECURITY TYPE(CONNAUTH) 除了上面两种命令行方式，也可以通过MQ Explorer关闭连接认证，如下图，在队列管理器的扩展属性中将连接认证一栏置为空即可。 通过以上注意点，一般可以解决连接MQ服务器的2035错误。]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>WebsphereMQ</tag>
      </tags>
  </entry>
</search>
